# pfuncs #


### Description ###

A simple library that translates strings of mathematical expressions into
callable functions. Several common built-in functions are implemented.


### The Func Class ###
All parsing & interpreting is handled within the top-level `Func` class. It can
be initialized with a mathematical expression (as a string) [recommended], or 
with an Abstract Syntax Tree generated by the internal Parser.

Sums, differences, products, quotients, and powers of functions are also implemented. That
is, if `f` and `g` are instances of the Func class, parse-able strings, or floats, then 
`f . g` results in another Func object, where `.` is the appropriate binary operator. 

The analytic derivative of a Func instance is accessed via the `.derivative` (or 
its alias `.d`) property. If _f_ is a function of _x_, _y_, and _z_, then `f.d['x']`
returns a Func representing the derivative of _f_ with respect to _x_. Similarly,
`f.d['x', 'y']` returns the derivative of _f_ with respect to both variables. If 
you want to know the derivative of _g(x)_ at _x=4_, then use `g.d[{'x': 4}]`. 

If the underlying expession of a Func instance is univariate, then it can 
be called with and without keywords (provided the keyword matches the variable
in the expression). If the underlying expression is multivariate, then keywords
must be used. Additionally, if only a subset of the variables are provided, then
the Func is curried, and returns another Func instance as a function of the 
non-provided variables (see Example 3 below).

In all calling situations - simple evaluation, currying, and differentiation - the arguments
can be ints or floats, parse-able string expressions, or Func instances. In the latter two 
cases, the composition of the functions is returned. Arguments of `numpy.ndarray` type are 
also handled in most cases, but because `pfuncs` wasn't designed with matrix operations in 
mind, errors may arise.



### Examples ###
1. Using the fixed point of <img src="https://render.githubusercontent.com/render/math?math=f(x) = 1 %2B 1/x"> to approximate the Golden Ratio
```python
phi = pfuncs.Func('1/x + 1')
p = 1
for _ in range(30):
		p = phi(p)
print(p)    # 1.6180339887496482
```

2. We can approximate Euler's constant _e_ using the first (historical) formula
```python
euler = pfuncs.Func('(1 + 1/n)**n')
print(euler(100))       # 2.704814
print(euler(n=5000))    # 2.718010
```
The convergence of this formula is obviously very slow, so `pfuncs` recognizes 'e' as a special constants in expressions:
```python
print(pfuncs.Func('e'))  # 2.718281828459045
```

3. Expressions with an arbitrary number of variables can also be translated to a function, provided the values are provided as keyword arguments when the function is called. Here we calculate the total payment on a 30-year mortgage, compounded monthly:
```python
mortgage = pfuncs.Func('p*(1 + r/12)**(12 * 30)')
principal, rate = 180000, 2/100
print(mortgage(p=principal, r=rate)) # 327817.616263
rate = 4/100
fixed_rate = mortgage(r=rate)
print(type(fixed_rate))              # <class 'pfuncs.callable.Func'>
print(fixed_rate(p=195000))          # 646132.112848
print(fixed_rate(250000))            # 828374.5036517356
print(mortgage(p=195000, r=rate))    # 646132.112848
```


### Built-in Functions ###
The following functions are recognized as built-in functions by `pfuncs`:

|    function    |      builtin name       |     |   function  |       builtin name      |
|:---------------|------------------------:| --- |:------------|------------------------:|
|       e^x      |         _exp( )_        |     | natural log |    _log( )_ or _ln( )_  |
|   log base 10  |         _log( )_        |     | square root |        _sqrt( )_        |
|   abs. value   |         _abs( )_        |     |   signum    |        _sign( )_        |
|      sine      |         _sin( )_        |     |   cosine    |        _cos( )_         |
|     tangent    |         _tan( )_        |     |   arcsine   |       _arcsin( )_       |
|    arccosine   |       _arccos( )_       |     |  arctangent |       _arctan( )_       | 
|     floor      |        _floor( )_       |     |   ceiling   |        _ceil( )_        |
| error function |         _erf( )_        |     |   minimum   |         _min( )_        |
|     maximum    |        _max( )_         |     | normal cdf  | _normcdf(x, mu, sigma)_ |
|   normal pdf   | _normpdf(x, mu, sigma)_ |     |             |                         |


#### Built-in Derivatives ####

The _min_, _max_, _normpdf_, and _normcdf_ functions do not have derivatives implemented yet; an error is thrown if the `.derivative` attribute of a Func with one of them is accessed. Following `numpy`'s footsteps of evaluating _sign(0)_ as _0_, the derivative of _abs( )_ is _0_ when the inner expression is _0_. In the same vein, derivatives of _sign_, _floor_, and _ceil_ ignore all discontinuities and return the zero function (i.e. _f'(x)=0_ for all _x_). All other derivatives are as expected. 


### Notes ###
* expressions are case-sensitive, so all built-in functions and constants (_e_ and _pi_ for now) need to be lowercase
* although not explicitly designed to handle numpy ndarray inputs, `pfuncs` accepts and evaluates them correctly as variable inputs. However, the Lexer and Parser are not designed to handle them as a term in the string expression


### Thanks ###
The parsing & interpreting framework are based almost solely on [Ruslan Spivak's wonderful _Let's Build a Simple Interpreter_](https://ruslanspivak.com/lsbasi-part1/) series of blog posts


### To-Do ###
* Allow for complex numbers. Went to all that trouble to implement _e_ - might as well make use of it