"""
module containing all the nodes ands leaves of the Abstract Syntax Tree
generated by the pfuncs parser
"""
class AST(object):
	""" Abstract Base Class for all nodes and leaves in AST """

	def __init__(self):
		pass

	def describe(self, level=0):
		"""
		allows us to visualize (albeit, in a crude way), the whole abstract syntax
		tree of a given mathematical expression. prints it to the console, with 
		indents used to show levels of the AST
		"""	

		indent = '    '

		# gets all the non-private attributes of the subclass into a list
		valid_attr = lambda d: (not d.startswith('_')) and (d != 'describe')
		attrs = [d for d in dir(self) if valid_attr(d)]

		# only prints the current AST object name when it's the first level
		if level == 0:
			print('{} with Attributes: '.format(self.__repr__()))

		# now, print the AST object's attributes
		for a in attrs:
			attr = getattr(self, a)
			supr = type(self).__bases__ # references the AST super class

			print('{indent}{attr_name}: {attr_value}'.format(
					indent=indent*(level+1),
					attr_name=a,
					attr_value=attr)
			)

			if isinstance(attr, supr):
				attr.describe(level=level+1)

	def __repr__(self):
		return '<{klass} Object>'.format(klass=type(self).__name__)


class BinaryOp(AST):

	def __init__(self, left, op, right):
		self.left = left
		self.op = op
		self.right = right


class UnaryOp(AST):

	def __init__(self, op, expr):
		self.op = op
		self.expr = expr


class Num(AST):

	def __init__(self, token):
		self.token = token
		self.value = self.token.value


class Var(AST):

	def __init__(self, token):
		self.token = token
		self.value = self.token.value


class Function(AST):

	def __init__(self, token, expr):
		self.token = token
		self.value = self.token.value
		self.expr = expr


class MultivarFunction(AST):

	def __init__(self, token, arguments):
		self.token = token
		self.value = self.token.value
		self.arguments = arguments


class Arg(AST):
	def __init__(self, expr):
		self.expr = expr