
import pfuncs.ast as ast

from pfuncs.tokens import Token
from pfuncs.generic import (
	ABCParser,
	ABCVisitor
)
from pfuncs.base import (
	# number, variable name, parentheses
	NUMBER, 
	ID,
	LPARE,
	RPARE,
	# mathematical operations
	PLUS, 
	MINUS,
	MUL,
	DIV,
	POWER
)


class AlgebraParser(ABCParser):
	"""
	Parses algebraic expressions with numbers, variables, addition, subtraction,
	multiplication, division, and exponentiation. Supports parsing of arbitrary
	parenthetically-nested expressions
	"""

	def __init__(self, lexer):
		super().__init__(lexer)

	def atom(self):
		"""
		atom : ID
			 | NUMBER
			 | LPARE expr RPARE
			 | (MINUS | PLUS) term
		"""
		token = self.current_token

		if token.type == ID:
			node = ast.Var(token)
			self.eat(ID)
			return node
		elif token.type == NUMBER:
			self.eat(NUMBER)
			return ast.Num(token)
		elif token.type == LPARE:
			self.eat(LPARE)
			node = self.expr()
			self.eat(RPARE)
			return node
		elif token.type in (MINUS, PLUS):
			self.eat(token.type)
			# sending the 'expr' to term() instead of expr() is what ensures
			# 	the unary operation functionality
			node = ast.UnaryOp(op=token,
								expr=self.term())
			return node

	def exponent(self):
		"""
		exponent : atom (POWER exponent)*
		"""
		node = self.atom()

		while self.current_token.type == POWER:
			token = self.current_token
			self.eat(POWER)

			# sending the 'right' attribute to exponent() instead of down to atom()
			# 	like other binary operations is what ensures exponentiation to 
			#	be right-associative
			node = ast.BinaryOp(left=node,
								op=token,
								right=self.exponent())
		return node

	def term(self):
		"""
		term : exponent ((MUL | DIV) exponent)*
		"""
		node = self.exponent()

		while self.current_token.type in (MUL, DIV):
			token = self.current_token
			self.eat(token.type)

			node = ast.BinaryOp(left=node,
								op=token,
								right=self.exponent())
		return node

	def expr(self):
		"""
		expr : term ((PLUS | MINUS) term)*
		"""
		node = self.term()

		while self.current_token.type in (PLUS, MINUS):
			token = self.current_token
			self.eat(token.type)

			node = ast.BinaryOp(left=node,
								op=token,
								right=self.term())
		return node

	def parse(self):
		""" Generates the AST. Probably will be overwritten by superclass """
		return self.expr()


class AlgebraInterpreter(ABCVisitor):
	"""
	Interprets an Abstract Syntax Tree with nodes & leaves generated by the 
	Algebra Parser, i.e. cannot handle built-in function calls
	"""

	def __init__(self, tree):
		super().__init__(tree)

	def visit_Num(self, node):
		return lambda x: node.value

	def visit_Var(self, node):
		return lambda x: x

	def visit_UnaryOp(self, node):
		if node.op.type == PLUS:
			return lambda x: + self.visit(node.expr)(x)
		elif node.op.type == MINUS:
			return lambda x: - self.visit(node.expr)(x)

	def visit_BinaryOp(self, node):
		if node.op.type == PLUS:
			return lambda x: self.visit(node.left)(x) + self.visit(node.right)(x)
		elif node.op.type == MINUS:
			return lambda x: self.visit(node.left)(x) - self.visit(node.right)(x)
		elif node.op.type == MUL:
			return lambda x: self.visit(node.left)(x) * self.visit(node.right)(x)
		elif node.op.type == DIV:
			return lambda x: self.visit(node.left)(x) / self.visit(node.right)(x)
		elif node.op.type == POWER:
			return lambda x: self.visit(node.left)(x) ** self.visit(node.right)(x)

	def interpret(self):
		return self.visit(self.tree)


