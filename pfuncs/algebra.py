"""
module for algebra-based parser and interpreter. These can function as stand-alone
objects, but for the purposes of the pfuncs library they act as superclasses for
the Parser and Interpreter objects in pfuncs.functions
"""
import pfuncs.ast as ast

from pfuncs.tokens import Token
from pfuncs.semantics import ScopedMemory
from pfuncs.generic import (
	ABCParser,
	ABCVisitor
)
from pfuncs.base import (
	# number, variable name, parentheses
	NUMBER, 
	ID,
	LPARE,
	RPARE,
	# mathematical operations
	PLUS, 
	MINUS,
	MUL,
	DIV,
	POWER
)


class Parser(ABCParser):
	"""
	Parses algebraic expressions with numbers, variables, addition, subtraction,
	multiplication, division, and exponentiation. Supports parsing of arbitrary
	parenthetically-nested expressions
	"""

	def __init__(self, lexer):
		super().__init__(lexer)

	def atom(self):
		"""
		atom : ID
			 | NUMBER
			 | LPARE expr RPARE
			 | (MINUS | PLUS) term
		"""
		token = self.current_token

		if token.type == ID:
			node = ast.Var(token)
			self.eat(ID)
			return node
		elif token.type == NUMBER:
			self.eat(NUMBER)
			return ast.Num(token)
		elif token.type == LPARE:
			self.eat(LPARE)
			node = self.expr()
			self.eat(RPARE)
			return node
		elif token.type in (MINUS, PLUS):
			self.eat(token.type)
			# sending the 'expr' to term() instead of expr() is what ensures
			# 	the unary operation functionality
			node = ast.UnaryOp(op=token,
								expr=self.term())
			return node

	def exponent(self):
		"""
		exponent : atom (POWER exponent)*
		"""
		node = self.atom()

		while self.current_token.type == POWER:
			token = self.current_token
			self.eat(POWER)

			# sending the 'right' attribute to exponent() instead of down to atom()
			# 	like other binary operations is what ensures exponentiation to 
			#	be right-associative
			node = ast.BinaryOp(left=node,
								op=token,
								right=self.exponent())
		return node

	def term(self):
		"""
		term : exponent ((MUL | DIV) exponent)*
		"""
		node = self.exponent()

		while self.current_token.type in (MUL, DIV):
			token = self.current_token
			self.eat(token.type)

			node = ast.BinaryOp(left=node,
								op=token,
								right=self.exponent())
		return node

	def expr(self):
		"""
		expr : term ((PLUS | MINUS) term)*
		"""
		node = self.term()

		while self.current_token.type in (PLUS, MINUS):
			token = self.current_token
			self.eat(token.type)

			node = ast.BinaryOp(left=node,
								op=token,
								right=self.term())
		return node

	def parse(self):
		""" Generates the AST. Probably will be overwritten by superclass """
		return self.expr()


class Interpreter(ABCVisitor):
	"""
	Interprets an Abstract Syntax Tree with nodes & leaves generated by the 
	pfuncs.algebra.Parser, i.e. cannot handle built-in function calls
	"""

	def __init__(self, tree, variables):
		super().__init__(tree)
		self.variables = variables

	def visit_Num(self, node):
		return node.value

	def visit_Var(self, node):
		v = self.scope.retrieve(node.value)
		return v

	def visit_UnaryOp(self, node):
		if node.op.type == PLUS:
			return + self.visit(node.expr)
		elif node.op.type == MINUS:
			return - self.visit(node.expr)

	def visit_BinaryOp(self, node):
		if node.op.type == PLUS:
			return self.visit(node.left) + self.visit(node.right)
		elif node.op.type == MINUS:
			return self.visit(node.left) - self.visit(node.right)
		elif node.op.type == MUL:
			return self.visit(node.left) * self.visit(node.right)
		elif node.op.type == DIV:
			return self.visit(node.left) / self.visit(node.right)
		elif node.op.type == POWER:
			return self.visit(node.left) ** self.visit(node.right)

	def interpret(self):

		if len(self.variables) == 1:
			def func(*args):
				if len(args) != 1:
					raise ValueError('Too many arguments.')

				# assign the only variable name to the given value
				self.scope = ScopedMemory(scope_name='pfunc', scope_level=1)
				self.scope.assign(self.variables[0], args[0])
				return self.visit(self.tree)

		else:
			def func(**kwargs):
				# assign the user-provided variable names and values to local memory
				self.scope = ScopedMemory(scope_name='pfunc', scope_level=1)
				for k, v in kwargs.items():
					self.scope.assign(k, v)
				# verifies user-provided variable names are all found in expression
				for v in self.scope.variables:
					if v not in self.variables:
						raise NameError(v) from None
					else:
						pass
				return self.visit(self.tree)

		return func